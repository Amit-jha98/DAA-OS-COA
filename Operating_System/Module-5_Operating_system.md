Great! Let's now begin **Module 5** with a **well-explained, point-by-point breakdown**, followed by **Module 6** in the next step. I’ll also include **PYQs (Previous Year Questions)** at the end.

---

## 📘 **Module 5: Memory Management**

**(Lecture – 9 hours)**

---

### 🔹 1. **Basic Concepts of Memory Management**

* OS memory management is the process of **allocating and deallocating** memory to various processes.
* Main goal: **Efficient utilization** of main memory (RAM).
* Tasks:

  * Track which memory parts are in use.
  * Decide which process gets memory.
  * Free memory when it’s no longer in use.

---

### 🔹 2. **Logical and Physical Address Map**

* **Logical Address** (aka Virtual Address): Generated by CPU during execution.
* **Physical Address**: Actual location in main memory.
* **MMU (Memory Management Unit)** translates logical → physical address.
* Logical ≠ Physical in virtual memory systems.

📝 Example:
If a program’s code refers to address `2000`, the OS might map it to physical address `52000`.

---

### 🔹 3. **Memory Allocation Techniques**

#### A. **Contiguous Memory Allocation**

* Each process gets a single block of contiguous memory.
* Simple but causes **fragmentation**.

##### 🔸 Types:

1. **Fixed Partitioning**:

   * Memory divided into fixed-size regions.
   * Easy but **internal fragmentation** (unused memory inside partition).

2. **Variable Partitioning**:

   * Allocates exactly as needed.
   * Leads to **external fragmentation** (free memory scattered across).

#### 🔸 Internal Fragmentation:

* Wasted memory **within** allocated block.

#### 🔸 External Fragmentation:

* Wasted memory **outside** allocated blocks (non-contiguous holes).

#### 🔸 Compaction:

* OS shifts processes to eliminate external fragmentation.
* Costly in CPU time.

---

### 🔹 4. **Paging**

* Breaks memory into **fixed-size pages (logical)** and **frames (physical)**.
* No external fragmentation, possible internal fragmentation.

#### 🔸 Principle:

* Logical address = (Page number, Offset)
* MMU maps page number to frame number.

#### 🔸 Hardware Support:

* **Page Table**: Maps logical pages to physical frames.
* **TLB (Translation Lookaside Buffer)**: Cache for page table entries.

#### 🔸 Protection:

* Each page entry can include **protection bits** (read, write, execute).

#### 🔸 Sharing:

* Two processes can **share pages** (like common library code).

---

### 🔹 5. **Segmentation**

* Divides memory by **logical sections**: code, data, stack, heap.
* Logical address = (Segment number, offset)

#### 🔸 Advantages:

* Closer to how programs are structured.
* Allows **dynamic growth** of segments (like stacks).

#### 🔸 Disadvantages:

* Suffers from **external fragmentation**.
* Needs **bounds checking** on segment offset.

---

### 🔹 6. **Virtual Memory**

* Allows execution of processes not fully in memory.
* **Demand paging**: Loads pages **only when needed**.
* Benefits:

  * More processes can be loaded.
  * Process can be larger than RAM.

---

### 🔹 7. **Page Fault**

* Occurs when a page is not in memory.
* OS loads it from secondary storage (disk).
* Causes:

  * Slowdown (due to disk access time)
  * Context switch

---

### 🔹 8. **Working Set**

* Set of pages actively used by a process during recent execution.
* Helps OS in deciding **which pages to keep** in memory.

---

### 🔹 9. **Dirty Page / Dirty Bit**

* A page that’s **modified** but not yet written back to disk.
* Dirty bit tells OS to **save page** to disk before replacing.

---

### 🔹 10. **Page Replacement Algorithms**

When a page fault occurs and memory is full, one page must be removed:

#### 🔸 a. **Optimal**

* Replaces page that will not be used **for the longest time**.
* Not practical, only used for benchmarking.

#### 🔸 b. **FIFO (First-In-First-Out)**

* Oldest loaded page is replaced.
* Simple but **may evict frequently used pages**.

#### 🔸 c. **Second Chance**

* Modified FIFO that gives a **"second chance"** if the page was recently used (based on reference bit).

#### 🔸 d. **NRU (Not Recently Used)**

* Pages classified by Reference and Modified bits.
* OS replaces page in **lowest priority class**.

#### 🔸 e. **LRU (Least Recently Used)**

* Removes the page **not used for longest time**.
* Requires hardware or software tracking.

---

## 🧾 PYQs (Previous Year Questions) – Module 5

1. **Explain paging and segmentation with hardware support.**
2. **Differentiate between internal and external fragmentation.**
3. **What is virtual memory? Describe demand paging with advantages.**
4. **Compare FIFO and LRU page replacement algorithms with examples.**
5. **Write short notes on: Dirty bit, Page fault, Working set.**

---
